## 자바의 컴파일 과정

#### 컴파일 순서

<img src="../img/javacompile1.png" width="500">

1. 프로그램이 실행되면 JVM은 OS로부터 프로그램이 필요로 하는 메모리를 할당받는다.

> JVM은 용도에 따라 메모리를 여러 영역으로 나눠 관리한다.

<br />

2. 자바 컴파일러 (javac, Java Compiler) 가 소스코드 (.java) 를 읽어들여 바이트 코드 (.class) 로 변환시킨다.

> 자바 바이트 코드 (.class) 파일은 아직 컴퓨터는 읽을 수 없고, JVM이 이해할 수 있는 코드이다.
> 바이트 코드의 각 명령어는 1바이트 크기의 Opcode와 추가 피연산자로 이루어져 있다.

<br />

3. 컴파일된 바이트 코드를 JVM의 클래스 로더 (Class Loader) 에게 전달한다.

> 클래스 로더 세부 동작
>
> (1) 로드 : 클래스 파일을 가져와서 JVM의 메모리에 로드한다.
> (2) 검증 : 자바 언어 명세 (Java Language Specification) 및 JVM 명세에 명시된 대로 구성되어 있는지 검사한다.
> (3) 준비 : 클래스가 필요로 하는 메모리를 할당한다. (필드, 메서드, 인터페이스 등등)
> (4) 분석 : 클래스의 상수 풀 내 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경한다.
> (5) 초기화 : 클래스 변수들을 적절한 값으로 초기화한다. (static 필드)

<br />

4. JVM 내에 로드된 바이트 코드는 실행 엔진 (Execution Engine) 을 통해 기계어로 해석된 뒤, 메모리 상 (Runtime Data Area) 에 배치된다.

> 이때, 실행 엔진은 두 가지 방식으로 변경한다.
>
> (1) 인터프리터 (Interpreter)
>
> 바이트 코드 명령어를 하나씩 읽어서 해석하고 실행한다.
> 하나하나의 실행은 빠르나, 전체적인 실행 속도가 느리다.

> (2) JIT 컴파일러 (Just-In-Time Compiler)
> 
> 인터프리터의 단점을 보완하기 위해 도입된 방식으로 바이트 코드 전체를 컴파일하여 바이너리 코드로 변경하고 이후에는 해당 메서드를 더이상 인터프리팅 하지 않고, 바이너리 코드로 직접 실행하는 방식이다.
>
> 하나씩 인터프리팅하여 실행하는 것이 아니라 바이트 코드 전체가 컴파일된 바이너리 코드를 실행하는 것이기 때문에 전체적인 실행속도는 인터프리팅 방식보다 빠르다.

<br />

5. 해석된 바이트 코드는 런타임 데이터 영역 (Runtime Data Area) 에 배치되어 실질적인 수행이 이루어 진다.